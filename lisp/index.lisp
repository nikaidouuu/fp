;- 기본 규칙
;1. 하나의 표현식은 괄호로 시작하고 괄호로 끝난다.
;2. 기본적으로 괄호의 첫 번째 요소는 함수의 이름이고, 이어지는 값들은 함수에 전달되는 인자들이다. - 전위 표기법(Prefix Notation)
;3. S-표현식은 식이다. 따라서 리스프 인터프리터에 의해 평가되어 값이 반환된다.
(+ 3 5)

;- S-표현식을 들여쓰는 규칙
;1. 중첩 괄호가 없는 간단한 구조의 경우에는 한 줄에 작성한다.
(+ 1 2 3 4 5)
;2. 중첩 괄호가 나오는 위치에서 다음 줄에 작성하되, 동일한 입력 인자들 간의 들여쓰기 레벨을 맞추도록 한다. 
;3. 닫는 괄호에 대해서는 들여쓰기를 하지 않는다.
(+ 1
   + 2 3))
(+
 (+ 1 2)
 (+ 3 4))
(+ 1
   (+ 2
      (+ 3 4)))
(+
 (+
  (+ 1 2)
  (+ 3 4))
 5)

;- 함수 정의
;(defun 함수_이름)
;(인자1 인자2...)
;"주석"
;함수_정의)
;리스프는 동적 타입 언어다. (런타임에 타입을 검사)
;함수는 반드시 하나의 값을 반환한다. 수학에서의 함수에 기초. f(x) = x^2 + 3x + 3
(defun sum
  (x y)
  "sum x and y"
  (+ x y))
(sum 1 2)

;- 전역 변수
;defvar은 한번 값을 할당하면 값에 대한 재할당이 무시된다.
(defvar *x* 123) ;123
(defvar *x* 500) ;123
;defparameter는 할당된 값을 자유롭게 바꿀 수 있다.
(defparameter *y* 123) ;123
(defparameter *y* 500) ;500
(+ *x* 3) ;126
(+ *y* 3) ;503

;- 지역 변수
;let을 사용하면 지역 변수를 정의할 수 있다. 다음의 예시는 x라는 지역 변수에 1이란 값을 대입하고, 그 밑의 식에서 x라는 변수를 사용한다.
(let ((x 1))
  (+ x 1)) ;2
;2개 이상의 지역 변수를 선언하는 예시는 다음과 같다.
(let ((x 1)
      (y 2))
  (+ x y)) ;3
;let*을 사용하면 지역 변수에 값을 할당 시 다른 지역 변수 값을 상호 참조할 수 있다.
(let* ((a 1)
       (b 2)
       (c (+ a b)))
  c) ;3

;- 조건 분기
;(if (조건식)
;    (true일 때)
;    (false일 때))
;전역 변수를 정의하고 그 값에 대한 조건식으로 분기하는 코드는 다음과 같다.
(defvar x 123)
(if (> x 3)
    "yes!"
    "no!") ; "Yes!"
;함수 내에서 if 분기를 사용하는 코드는 다음과 같다.
(defun compare3 (x)
  (if (> x 3)
      "bigger"
      "smaller"))
(compare 5) ;bigger
(compare 2) ;smaller
;if 표현식에는 하나의 맹점이 있다. 바로, true에 대해 2개 이상의 표현식을 넣을 수 없다는 것이다.
;조건식이 참인 경우 2개의 표현식을 연달아 평가받고 싶어 다음과 같이 코드를 작성하면 에러가 발생한다.
(defvar x 123)
(if (> x 3)
    (print "yes")
    (print "and this too!")
    (print "no")) ;- EVAL: too many parameters for special operator IF
;이때는 progn이란 키워드를 사용하여 2개의 표현식을 하나의 표현식으로 묶으면 된다.
;progn은 여러 표현식을 순서대로 평가한 후에 마지막 표현식의 결괏값을 반환한다.
(defvar x 123)
(if (> x 3)
    (progn
        (print "yes")
        (print "and this too!"))
    (print "no")) ;yes -> and this too! -> and this too!
;다른 프로그래밍 언어의 switch문과 비슷한 cond라는 키워드가 있다. 관례적으로 조건식의 마지막에는 (t "else")처럼 else에 해당하는 평가식을 기재한다.
(defvar x 12)
(cond
   ((< x 0) "minus")
   ((> x 10) "over 10")
   (t "else"))

;- 리스프 표현식
;리스프라는 이름은 LISt Processing의 약자다. 리스트 처리가 리스프의 핵심 목표였음이 분명하다. 리스트는 복수의 데이터가 줄줄이 연결된 자료 구조다.
;다음은 리스트 표현식의 예다. 괄호 안에 데이터를 넣고 그 앞에 '(쿼트)를 넣어 주면 리스트 데이터로 인식된다.
'(1 2 3 4 5)
;한편, 지금까지 사용해 온 S-표현식의 일반적인 형태는 다음과 같다. (함수_이름 인자1 인자2...)
;S-표현식 자체가 리스트다. 리스프의 코드 자체가 리스트인 것이다.
;이처럼 코드와 데이터가 같은 방식으로 기술되고 처리되는 특징을 code as data 혹은 동형성이라고 표현한다.
;리스프의 이러한 특징은 데이터를 코드로 바꿔서 즉석에서 실행할 수 있게 해준다. 즉, 예를 들면 리스프로 웹 서버를 만들었다고 하자.
;사용자가 HTTP 요청으로 리스프 코드를 전달하면, 해당 코드를 즉석에서 평가하여 수행하는 것이 가능하다.
;더 간단하게는 사용자의 표준 입력을 받아들여서 그것을 리스프의 코드로 실행하는 것도 가능하다.
(loop 
   (print 
       (eval 
          (read))))
(+ 1 2) ;3
;이 코드를 실행하면 사용자의 입력을 읽어서 해당 내용을 평가한 결과를 출력해 준다. 완벽한 리스프 인터프리터 위의 또 다른 인터프리터다.
;가장 들여쓰기 깊이가 깊은 read가 먼저 수행된다. read는 사용자의 입력을 기다렸다가 반환하는 함수다.
;이어서 해당 입력값을 eval이 평가하고 평가 결과를 print가 화면에 출력해 준다. 이 과정을 loop를 통해 무한 반복하고 있다.

;- 콘즈셀과 CAR, CDR
;리스프의 리스트는 링크드 리스트다. 링크드 리스트는 메모리상에 서로 떨어진 공간에 위치하는 복수의 데이터를 연결하여 표현한 자료 구조로, 하나의 요소가 다음 요소의 메모리 주소를 가지고 있는 구조다.
;리스프에서는 리스트의 각 요소를 콘즈셀(Cons Cell)이라 부르고, 그 요소의 데이터를 가리키는 포인터를 CAR, 다음 콘즈셀을 가리키는 포인터를 CDR이라고 한다.
;CAR: 알파벳순으로 A가 먼저 나오니 데이터를 가리키는 포인터(?)
;CDR: 알파벳순으로 D가 뒤에 나오니 다음 콘즈셀을 가리키는 포인터(?)
;리스프에서 NIL은 빈 리스트를 의미한다. 모든 콘즈셀의 CDR은 자기 뒤에 달려있는 리스트를 가리키고 있다고 볼 수 있는데, 마지막 콘즈셀의 CDR은 빈 리스트인 NIL을 가리키고 있는 것이다.
;한편, CAR과 CDR은 리스프의 기본 함수이기도 하다.
(CAR '(1 2 3)) ;1 첫 번째 요소를 반환
(CDR '(1 2 3)) ;(2 3) 첫 번째를 제외한 나머지 리스트
;그럼, (1 2 3)이라는 리스트에서 두 번째 요소를 얻으려면 어떻게 해야 할까? 먼저 CDR를 통해 (2 3)을 얻고 거기에 CAR을 적용하여 2를 얻으면 된다.
(CAR
  (CDR
    '(1 2 3))) ;2
;(1 2 3)에서 마지막 요소를 얻는 방법은 어떻게 될까? CDR를 통해 (2 3)을 얻고 여기에 다시 CDR을 적용해서 (3)을 얻은 후에 CAR을 적용하면 된다.
(CAR
  (CDR
    (CDR
      '(1 2 3))))
;리스트를 CAR(첫 번째 요소)과 CDR(나머지 리스트)로 나눠서 생각하는 것은 모든 함수형 프로그래밍에서 반복적으로 나타나는 개념이다.
;또한, 리스트의 각 요소가 CAR과 CDR로 구성되어 줄줄이 비엔나 소시지처럼 연결되었다는 것은 리스트에 대한 재귀 함수를 정의하는 데 도움이 된다.
;리스트에 값을 추가할 때는 크게 cons와 append 함수를 사용한다. cons는 리스트의 첫 번째 위치에 요소를 하나 추가할 때 사용한다.
(cons 1 '(2 3)) ;(1 2 3)
;한편, append 함수는 리스트와 리스트를 합쳐서 하나의 리스트로 만들 때 사용한다.
(append '(1 2) '(3 4)) ;(1 2 3 4)
;cons로 리스트와 리스트를 하나로 합치면 다음과 같이 중첩된 리스트로 합쳐진다.
(cons '(1 2) '(3 4)) ;((1 2) 3 4)

;- 리스트와 재귀 함수
;for문은 i라는 변수의 값을 바꿔가면서 수행된다는 측면에서 함수형 언어의 원리에 어긋난다. 함수형 언어에서는 반복문을 재귀 함수로 구현할 수 있다.
;재귀 함수란, 함수의 정의 내에서 자기 자신을 호출하는 함수를 말한다. 밑의 함수는 입력 인자가 10보다 크면 "finish"라는 문자열을 반환하고, 그렇지 않다면 현재 인잣값을 출력한 후 거기에 1을 더해서 자기 자신을 호출한다.
(defun myself (x)
  (if (> x 10)
    "finish"
    (progn
      (print x)
      (myself (+ 1 x)))))
;첫째. 재귀 함수는 자기 자신을 호출해야 한다. 재귀 함수의 정의에 해당하는 부분이다.
;둘째. 재귀 함수는 종료 조건이 있어야 한다.
;셋째. 재귀 함수가 종료 조건에 수렴하기 위해서는 반드시 자기 자신에게 전달된 입력값과 다른 값을 사용해서 자기 자신을 호출해야 한다.
;함수형 프로그래밍의 원리에 따르면 함수 내에서는 외부 변수에 접근하지 않아야 한다. 이에 따라 재귀 함수의 종료 조건은 기본적으로 입력 인자만을 참조해야 한다.
;그러므로 입력 인자가 없는 함수는 재귀 함수에 적합하지 않다. 또한, 현재 입력 인자의 값과 동일한 값으로 재귀 함수를 호출하게 되면 무한 루프에 빠지게 될 뿐이다.

;- 피보나치 수 구하기
(defun fibo (n)
  (cond
      ((= n 1) 1)
      ((= n 2) 1)
      (t (+
          (fibo (- n 1))
          (fibo (- n 2))))))
fibo(10) ;55

;-리스트의 합을 구하는 재귀 함수
(defun sum-of-list (input-list)
   (if (null input-list)
     0
     (+
      (CAR input-list)
      (sum-of-list (CDR input-list)))))
(sum-of-list `(1 2 3 4 5)) ;15

;- 리스트를 전부 출력하는 재귀 함수
(defun print-all (input-list)
  (if (null input-list)
    "finish"
    (progn
      (print (CAR input-list))
      (print-all (CDR input-list)))))
(print-all '(1 2 3 4 5)) ; 1 -> 2 -> 3 -> 4 -> 5 -> finish
;재귀 함수로 리스트를 다룰 때는 다음 두 가지 규칙을 기억하면 된다.
;첫째. 종료 조건은 입력 리스트가 빈 리스트일 때로 한다.
;둘째. 입력 리스트의 CDR을 인자로 재귀 호출한다.

;-리스트의 최댓값 구하기
;첫째. 함수의 이름은 max-of-list로 하고, 길이가 n인 리스트를 입력으로 받아 그 최댓값을 반환하는 함수를 작성할 것이다.
;둘째. 구체적인 입력 인자로 [1, 2, 3]과 같이 세 개의 값으로 구성된 리스트를 생각해 보자.
;셋째. max-of-list([1, 2, 3]) = max(1, max-of-list([2, 3]))다.
;넷째. 위 식을 일반화하면 다음과 같이 된다. max-of-list(list) = max(list의 첫 번째 요소, max-of-list(list의 첫 번째 요소를 제외한 리스트))
;다섯째. 종료 조건은 길이가 1인 리스트에 대해 하나 있는 그 요소를 반환하면 된다.
(defun max-of-list (input-list)
  (cond
    ((null input-list) "NOT SENSE")
    ((= 1 (list-length input-list)) (CAR input-list))
    ((< 1 (list-length input-list))
     (max
      (CAR input-list)
      (max-of-list (CDR input-list))))))
(max-of-list '(9 4 2 10 1)) ;10

;- 리스트와 임의의 숫자를 입력으로 받아 해당 숫자가 리스트에 있으면 "yes" 없으면 "no"를 반환하는 재귀 함수 is-exist를 작성하라.
(defun is-exist (input-list number)
  (cond
      ((null input-list) "no")
      ((= (CAR input-list) number) "yes")
      (t (is-exist (CDR input-list) number))))
(is-exist '(1 2 3) 3) ;yes
(is-exist '(1 2 3) 4) ;no

;- 리스트를 반환하는 재귀 함수
;함수형 언어에서는 리스트를 인자로 받아서 새로운 리스트를 반환하는 재귀 함수 패턴도 많이 사용된다. 리스트의 모든 요소에 1을 더한 새로운 리스트를 반환하는 재귀 함수의 코드는 다음과 같다.
(defun add-one-to-list (input-list)
  (if (null input-list)
      NIL
      (cons
       (+ 1 (CAR input-list))
       (add-one-to-list (CDR input-list)))))
(add-one-to-list '(1 2 3)) ;(2 3 4)
;종료 조건은 입력 리스트가 빈 리스트일 때로 한다.
;cons 함수를 사용해서 리스트의 첫 번째 요소를 가공한 값을 재귀 호출하여 얻은 리스트에 추가한다.

;- 입력 리스트의 각 요소를 중복 삽입한 리스트를 반환하는 재귀 함수 duplicate-elem을 작성하라.
(defun duplicate-elem (input-list)
  (if (null input-list)
      NIL
      (cons
       (CAR input-list)
       (cons
        (CAR input-list)
        (duplicate-elem (CDR input-list))))))
(duplicate-elem '(1 2 3)) ;(1 1 2 2 3 3)

;- 숫자로 구성된 리스트를 입력으로 받아 짝수인 숫자만 포함된 리스트를 반환하는 재귀 함수 filter-odd를 작성하라.
(defun filter-odd (input-list)
  (if (null input-list)
      NIL
      (if (evenp (CAR input-list))
       (cons
         (CAR input-list)
         (filter-odd (CDR input-list))
       )
       (filter-odd (CDR input-list)))))
(filter-odd '(1 2 3 4 5)) ;(2 4)

;- 람다식
;모든 함수형 언어는 람다식(Lamdba Expression)을 통해 익명 함수를 만들어 변수처럼 다룰 수 있다. 
;변수처럼 다룰 수 있다는 것을 '1급 시민'이라고 표현한다.
(lambda (x) (+ x 1)) ;λx.x+1와 같다
((lambda (x) (+ x 1)) 1) ;(λx.x+1) 1와 같다

;- 고차함수
;고차 함수는 함수를 인자로 받아들이거나 반환하는 함수를 말한다.
;리스프의 대표적인 고차 함수로는 mapcar, remove-if, reduce가 있다.
;mapcar는 함수와 리스트를 인자로 받아들여서 리스트의 각 요소에 함수를 적용한 결과값으로 구성된 리스트를 반환한다. 그냥 map이구나..
(mapcar
 (lambda (x) (+ x 1))
 '(1 2 3)) ;(2 3 4)
;remove-if 함수는 함수와 리스트를 인자로 받아들이고 리스트의 각 요소에 함수를 적용해서 결과값이 true인 요소를 제외한 리스트를 반환한다. 그냥 reject구나..
(remove-if
 (lambda (x) (= x 2))
 '(1 2 3)) ;(1 3)
;reduce도 역시 함수와 리스트를 인자로 받아들이는데, 두 고차 함수와는 조금 다르게 동작한다. 두 고차 함수는 함수가 요소 하나에 대해 적용되어 그 결과로 구성된 리스트를 반환하는데,
;reduce는 두 개의 요소씩 적용되어 최종적으로 하나의 값을 반환한다. 제일 먼저 리스트의 가장 왼쪽에 있는 두 요소에 대해 람다식이 적용되고, 그 결과와 다음의 요소가 적용되는 것이 반복된다. reduce네..
(reduce
 (lambda (x y) (+ x y))
 '(1 2 3 4 5)) ;15
