/*
- Promise의 특징
  Promise을 사용하면 일련의 작업을 미래 값과 연결하여 연속(continuation)을 구현할 수 있다. continuation monad!!
  Promise는 비동기와 장기 실횅 연산 그리고 결과나 에러를 구독할 수 있는 미래 값을 래핑한 데이터 유형.
  기본 작업이 완료되어 계산된 결괏값을 구독자(subscriber)가 받게 될 때 프로세스가 완료된 것으로 간주한다.
  Promise가 실행된 후에는 값을 변경할 수 없으므로 사실상 함수형 특성인 불변 타입이다.
*/

/*
- Promise의 단점
  1. 마우스 움직임이나 파일 스트림의 바이트 시퀀스처럼 둘 이상의 값을 생성하는 데이터 소스를 처리할 수 없다. (EventEmitter가 필요함)
  2. RxJS에 있는 에러 발생 시 재실행하는 기능이 Promise에는 없다.
  3. 가장 중요한 단점은 Promise는 불변이기 때문에 취소할 수 없다는 점이다.
*/
const getItems = () => ajax('/items')
const getInfo = item => ajax(`/data/${item.getId()}/info`)
const getFiles = dataInfo => ajax(`/data/files/${dataInfo.files}`)
const processFiles = files => console.log(files)

getItems()
  .then(items => items.map(getInfo))
  .then(promises => Promise.all(promises))
  .then(infos => infos.map(getFiles))
  .then(promises => Promise.all(promises))
  .then(processFiles)



/*
- RxJS 이해하기
  RxJS(Reactive Extensions for JavaScript)는 파일 읽기, HTTP 호출, 키 입력 또는 마우스 움직임 등
  흔한 이벤트의 소스를 처리하는 단일 프로그래밍을 사용하여 콜백 또는 Promise 기반 라이브러리를 정확히 같은 방식으로 대체한다.
  예를 들어 콜백으로 각 마우스 이벤트를 독립적으로 처리하는 대신에 RxJS로 모든 이벤트를 결합하여 처리한다.
*/

/* 
- 스트림 측면에서 생각하기: 데이터의 흐름과 전파
  수천가지의 키 입력, 움직임 이벤트, 터치 동작, 원격 HTTP 호출 등 무엇을 다루든지 RxJS는 이러한 모든 데이터 소스을 데이터 스트림이라 한다.
  전통적으로 스트림이라는 용어는 프로그래밍 언어에서 파일 읽기, 소켓 읽기, HTTP 서버에 데이터 요청하기 같은 I/O 작업과 관련된 추상 객체로 사용되었다.
  예를 들어 Node.js는 이 작업을 수행하기 위해 읽고 쓰기가 가능한 이중 스트림을 구현한다. 
  RP 세계에서는 소비할 수 있는 모든 데이터 소스를 의미하는 것으로 스트림의 정의를 확장한다.
  스트림은 배열과 매우 유사한 데이터의 컨테이너 또는 래퍼이다. 따라서 배열의 리터럴 표기법인 []로 이를 나타냄.
  또한 스트림을 가르키는 변수를 한정하는 데는 접미사 $를 사용하는 것이 일반적이다. (핀란드 표기법이라고 부름)
  RP는 데이터의 흐름과 전파가 중심.
*/
let a = 20 // A$ = [20] 스트림을 20으로 초기화한다.
let b = 22 // B$ = [22] 스트림을 22로 초기화한다.
let c = a + b // C$ = A$.concat(B$).reduce(adder) -> [42] 42를 담은 새 컨테이너를 얻기 위해 두 스트림을 연결하고 가산 함수를 적용.

a = 100 // A$.push(100) 새 값을 A$에 주입.
// 명령형: c = 42, a를 변경했다는 사실은 c 값에 영향을 미치지 않았다. 즉 변화의 전파가 일어나지 않았다.
// 반응형: c = 122, 변화의 전파가 있는 스트림 세계에서는 A$가 새로운 값을 받으면(새로운 이벤트) 이 상태는 A$가 속한 모든 스트림을 통해 주입된다.

/*
- 파이프라인
파이프라인은 데이터를 사용할 수 있을 때 순서대로 실행되는 일련의 로직 영역이다.
파이프라인은 주어진 입력을 원하는 출력으로 변환할 수 있게 하는 것이며, 본질적으로 비즈니스 로직이 실행되는 곳임.
*/

/*
- 모든 것이 스트림이다
RxJS는 스트림을 구독하고 관리하기 위해 일급 객체로 데이터를 전달하고 다른 스트림들과 결합할 수 있는 경량 데이터 타입을 제공한다.
다음과 같이 단일 값으로 스트림 하나를 만들 수 있다. Stream(42)
이때 스트림은 스트림을 듣는 구독자(또는 옵저버)가 있을 때까지 실제로 아무 일도 하지 않고 유휴 상태로 있다.
이는 생성되자마자 작업을 실행하는 Promise와는 매우 다르다. 어떻게 보면 스트림은 구독자가 연결된 후에만 실행하므로 지연(lazy) 데이터 타입이라 볼 수 있다.
*/
Stream(42).subscribe(val => {
  console.log(val) // 42
})

Strem(1, 2, 3, 4, 5).subscribe(val => {
  console.log(val) // 1 -> 2 -> 3 -> 4 -> 5,
})

Stream([1, 2, 3, 4, 5])
  .filter(num => (num % 2) === 0)
  .map(num => num * num)
  .subscribe(val => console.log(val))

/*
- 프로그램에서 시간 개념의 추상화
비동기 코드에서 가장 어려운 부분은 지연 시간과 대기 시간을 처리하는 것이다.
RxJS는 자바스크립트의 일급 객체로서 시간에 따라 연속적인 이벤트 시퀀스의 개념을 제시하는데, 이는 자바스크립트를 위한 진정한 이벤트 하위 시스템이다.
시간이 지남에 따라 소스에 상관없이 같은 프로그래밍 모델로 추상화되므로 코드가 완전히 선형이고 동기인 것처럼 데이터를 변환할 수 있다.
일반 동기 데이터로 처리했던 것을 다음과 같이 RxJS를 사용하면 시간 기반 비동기 이벤트 시퀀스 스트림으로 소비할 수 있다.
*/
Stream(loadMagazines('/subscriptions/magazines'))
  .filter(magazie => magazie.month === 'July')
  .subscribe(magazie => console.log(magazie.title))

/*
- Rx 스트림의 컴포넌트
1. 생산자(Producer)
데이터의 소스. 스트림에는 항상 데이터 생산자가 있어야 하며, RxJS에서 수행할 모든 로직의 시작점이 된다.
실제로 생산자는 독립적으로 이벤트를 생성하는 무언가(단일 값, 배열, 마우스 클릭, 파일로부터 읽어온 바이트 스트림에 이르기까지)에서 생성된다.
이러한 생산자를 옵저버 패턴에서는 서브젝트라고 정의하고, RxJS에서는 관찰될 수 있는 무언가라는 의미로 옵저버블이라 부른다.
옵저버블은 알람을 푸시하는 역할만 해서 이 동작을 실행 후 잊기(fire-and-forget)라 부른다. 즉, 생산자는 이벤트 방출에만 관여하고 이벤트 처리에는 관여하지 않는다.

2. 소비자(Consumer)
전체적으로 균형을 맞추려면 생산자로부터 이벤트를 받아들여 특정 방식으로 해당 이벤트를 처리하는 소비자가 있어야 한다.
소비자(옵저버)가 소비할 이벤트에 대해 생산자를 듣기 시작하면 스트림이 생기게 되고, 이 시점에 스트림은 이벤트를 푸시하기 시작한다.
스트림은 생산자에서 소비자로만 이동하며 다른 방향으로는 이동하지 않는다. 다시 말해, 사용자가 키보드의 키를 누르면 다른 프로세스에서 소비되려고 흘러가는 이벤트를 생산하게 된다.
기초 수준에서 다시 보면 스트림은 생산자와 소비자만을 요구한다. 소비자가 생산자에서 이벤트를 받기 시작하면 스트림을 생설할 수 있다.

3. 데이터 파이프라인(data pipeline)
RxJS의 한 가지 장점은 생산자에서 소비자로 전달되는 데이터를 조작하거나 편집할 수 있다는 점이다.
이는 메서드 목록(옵저버블 연산자로 알려진 메서드들)이 실행되는 곳이다. 이렇게 하면 두 개체 간 관심사의 분리가 촉진되고 코드의 모듈성에도 큰 도움이 된다.

4. 시간(time)
이 모든 것을 뒷받침하는 암시적 요소는 시간이다. 모든 RxJS에는 항상 시간의 기본 개념이 있어 스트림을 조작하는 데 사용할 수 있다.
시간은 정상 속도로 항상 실행될 필요는 없고, 요구 사항에 따라 더 느리게 또는 더 빠르게 실행되는 스트림을 생성할 수 있다.
*/
Stream.timerInSeconds() // 생산자
  .interval() // 시간, 파이프라인 함수1
  .map(x => x.value) // 시간, 파이프라인 함수2
  .filter(x => x % 2 === 0) // 시간, 파이프라인 함수3
  .take(10) // 시간, 파이프라인 함수4
  .subscribe(value => console.log(value)) // 시간, 소비자

Stream(ajax('/items'))
  .streamMap(item =>
    Stream(ajax(`/data/${item.getId()}/info`))) // 스트림은 다른 스트림을 구성할 수도 있다.
  .streamMap(dataInfo =>
    Stream(ajax(`/data/files/${dataInfo.files}`)))
  .subscribe(processFiles)